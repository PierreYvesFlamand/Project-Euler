/**
 * Problem 61 - Cyclical Figurate Numbers
 * 
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
 * 
 * Triangle     P_{3,n} = n(n+1)/2    1, 3,  6, 10, 15, ...  -> n( n + 1)/2
 * Square       P_{4,n} = n^2         1, 4,  9, 16, 25, ...  -> n(2n + 0)/2
 * Pentagonal   P_{5,n} = n(3n-1)/2   1, 5, 12, 22, 35, ...  -> n(3n - 1)/2
 * Hexagonal    P_{6,n} = n(2n-1)     1, 6, 15, 28, 45, ...  -> n(4n - 2)/2
 * Heptagonal   P_{7,n} = n(5n-3)/2   1, 7, 18, 34, 55, ...  -> n(5n - 3)/2
 * Octagonal    P_{8,n} = n(3n-2)     1, 8, 21, 40, 65, ...  -> n(6n - 4)/2
 * 
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 * 
 *  - The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
 *  - Each polygonal type: triangle (P_{3,127}=8128), square (P_{4,91}=8281), and pentagonal (P_{5,44}=2882), is represented by a different number in the set.
 *  - This is the only set of 4-digit numbers with this property.
 * 
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 */



let answer;

let triangleNumbers = [];
let squareNumbers = [];
let pentagonalNumbers = [];
let hexagonalNumbers = [];
let heptagonalNumbers = [];
let octagonalNumbers = [];

for (let i = 1; ; i++) {
    const newTriangleNumber = getP(3, i);
    const newSquareNumber = getP(4, i);
    const newPentagonalNumber = getP(5, i);
    const newHexagonalNumber = getP(6, i);
    const newHeptagonalNumber = getP(7, i);
    const newOctagonalNumber = getP(8, i);

    if (
        newTriangleNumber >= 10000 &&
        newSquareNumber >= 10000 &&
        newPentagonalNumber >= 10000 &&
        newHexagonalNumber >= 10000 &&
        newHeptagonalNumber >= 10000 &&
        newOctagonalNumber >= 10000
    ) break;

    if (newTriangleNumber >= 1000 && newTriangleNumber < 10000) triangleNumbers.push({ p: i, result: newTriangleNumber });
    if (newSquareNumber >= 1000 && newSquareNumber < 10000) squareNumbers.push({ p: i, result: newSquareNumber });
    if (newPentagonalNumber >= 1000 && newPentagonalNumber < 10000) pentagonalNumbers.push({ p: i, result: newPentagonalNumber });
    if (newHexagonalNumber >= 1000 && newHexagonalNumber < 10000) hexagonalNumbers.push({ p: i, result: newHexagonalNumber });
    if (newHeptagonalNumber >= 1000 && newHeptagonalNumber < 10000) heptagonalNumbers.push({ p: i, result: newHeptagonalNumber });
    if (newOctagonalNumber >= 1000 && newOctagonalNumber < 10000) octagonalNumbers.push({ p: i, result: newOctagonalNumber });
}

// for (const triangleNumber of triangleNumbers) {
//     console.log(findChains(triangleNumber, [squareNumbers, pentagonalNumbers]));
// }
console.log(JSON.stringify(findChains({ p: 127, result: 8128 }, [squareNumbers, pentagonalNumbers])));



// for (const triangleNumber of triangleNumbers.slice(0, 2)) {
//     const possibleArrays = [squareNumbers, pentagonalNumbers];

//     for (const possibleArray of possibleArrays) {
//         const possibleArrays = possibleArrays
//         possibleArray.splice(possibleArrays.findIndex(i => i === possibleArray), 1);
//         console.log(possibleArray);
//     }

//     // for (const squareNumber of squareNumbers.filter(squareNumber => Math.floor(squareNumber.result / 100) === triangleNumber.result % 100)) {
//     //     const result = pentagonalNumbers.filter(pentagonalNumber => Math.floor(pentagonalNumber.result / 100) === squareNumber.result % 100);
//     //     if (result.length) {

//     //     }
//     // }
// }

module.exports = answer;

function getP(c, n) {
    return (n * ((c - 2) * n + (4 - c))) / 2;
}

function findChains(firstElement, arrays, results = []) {
    // console.log(results);
    for (const array of arrays) {
        const possibilities = array.filter(item => Math.floor(item.result / 100) === (results[results.length - 1] || firstElement).result % 100);

        const isFirstResult = results.length === 0;
        for (const possibility of possibilities) {
            if (haveCommonInteger(results.map(i => i.p), possibilities.map(i => i.p))) continue;
            if (String(possibility.result).split('')[2] === '0') continue;

            if (isFirstResult) results.push([firstElement]);

            results = results.map(result => findChains(firstElement, arrays.filter((_, i) => i !== arrays.findIndex(item => item === array)), [result, possibility]));
        }
    }

    return results;
}

function haveCommonInteger(arr1, arr2) {
    const set1 = new Set(arr1);
    const set2 = new Set(arr2);

    for (const item of set1) {
        if (set2.has(item)) {
            return true;
        }
    }

    return false;
}